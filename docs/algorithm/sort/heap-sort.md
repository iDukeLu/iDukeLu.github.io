---
title: 堆排序
authors: Duke Lu
date: 2021-04-28
tags: [算法, 排序]
sidebar_position: 4
---

## 概念
![]()


堆排序是一种高效的排序算法，基于堆这种数据结构实现。堆是一种特殊的完全二叉树，其中每个节点的值都大于或等于（最大堆）或小于或等于（最小堆）其子节点的值。

堆排序的基本思想是利用堆的性质进行排序。它的主要步骤包括：
1. **构建堆**：将待排序的数组看成一个完全二叉树，通过自底向上的方式调整数组中的元素，使得它们满足堆的性质。这个过程称为堆化（heapify）。
2. **排序**：每次将堆顶元素（即最大值或最小值）与堆的最后一个元素交换位置，然后重新调整堆，使得剩余元素重新满足堆的性质。重复这个过程，直到所有元素都排好序。

堆排序具有以下特点：
- 时间复杂度为O(nlogn)，其中n是待排序数组的长度。堆排序的建堆过程的时间复杂度为O(n)，每次调整堆的时间复杂度为O(logn)。
- 空间复杂度为O(1)，是一种原地排序算法，不需要额外的存储空间。
- 不稳定性：由于交换元素可能会破坏相同元素的原始顺序，因此堆排序是一种不稳定的排序算法。

堆排序适用于各种数据规模，尤其适用于需要原地排序且性能要求较高的情况。

## 优缺点


## 代码实现

```go
// 堆排序函数
func HeapSort(arr []int) {
	n := len(arr)

	// 构建最大堆
	for i := n/2 - 1; i >= 0; i-- {
		heapify(arr, n, i)
	}

	// 逐个将堆顶元素移到数组末尾，再重新调整堆
	for i := n - 1; i > 0; i-- {
		arr[0], arr[i] = arr[i], arr[0] // 交换堆顶和当前元素
		heapify(arr, i, 0)              // 重新调整堆
	}
}

// 调整堆
func heapify(arr []int, n, i int) {
	largest := i // 初始化最大元素的索引为根节点
	left := 2*i + 1
	right := 2*i + 2

	// 找出左右子节点中的最大值
	if left < n && arr[left] > arr[largest] {
		largest = left
	}
	if right < n && arr[right] > arr[largest] {
		largest = right
	}

	// 如果最大元素不是根节点，则交换它们的位置，并递归调整堆
	if largest != i {
		arr[i], arr[largest] = arr[largest], arr[i]
		heapify(arr, n, largest)
	}
}
```

## 总结
堆排序：通过构建最大堆(最小堆)，然后不断从堆顶取值和调整堆。

复杂度：
- 平均时间复杂度：O(nlogn)
- 最坏时间复杂度：O(nlogn)
- 最优时间复杂度：O(nlogn)
- 空间复杂度：O(1)

---

更多参考：[堆排序-维基百科](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F)