---
title: Java 虚拟机运行时的数据区域（简单理解）
authors: Duke Lu
date: 2018-06-03
tags: [java, jvm]
---

## Java 虚拟机运行时的数据区域图示
![Java 虚拟机运行时的数据区域](https://upload-images.jianshu.io/upload_images/12158715-2d7103aacd2e8185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<!--truncate--> 

## 程序计数器（Program Counter Register）
**简单理解：线程私有、行号指示器**

**程序计数器**：是一小块内存区域，它可以看作是当前线程所执行字节码的行号指示器。
字节码解释器工作时，就是通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖程序计数器来完成。

- 记录的内容
执行一个 Java 方法：记录的是，正在执行的虚拟机字节码指令的地址
执行一个 Native 方法：计数器的值为空

- 异常
唯一一个在 Java 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域

## Java 虚拟机栈（Java Virtual Machine Stacks）
**简单理解：线程私有、描述 Java 方法执行过程**

**虚拟机栈**：描述 Java 方法执行的内存模型。它的生命周期同线程。
每个方法执行的时候都会创建一个栈桢，每个方法的调用直至执行完成，就对应一个栈桢在虚拟机栈中入栈到出栈道过程

- 栈桢（Stack Frame）：存储局部变量表、操作数栈、动态链表、方法出口等信息

- 局部变量表：存放编译期可知的各种基本数据类型、对象引用、returnAddress类型

- 异常
`StackOverflowError`：线程请求的栈深度大于虚拟机允许的深度时，抛出
`OutOfMemoryError`：虚拟机栈动态扩展时无法申请到足够内存时，抛出

## 本地方法栈（Native Method Stack）
**简单理解：线程私有、描述 Native 方法执行过程**

**本地方法栈**：与 Java 虚拟机栈发挥到作用非常相似。
虚拟机栈：为虚拟机执行 Java 方法服务；本地方法栈：为虚拟机执行 Native 方法服务

- 异常
`StackOverflowError`：线程请求的栈深度大于虚拟机允许的深度时，抛出
`OutOfMemoryError`：虚拟机栈动态扩展时无法申请到足够内存时，抛出

## Java 堆（Java Heap）
**简单理解：线程共享、存放对象实例**

**Java 堆**：被所有线程共享的一块内存区域，在虚拟机启动时创建。
Java 堆内存区域的唯一目的就是：存放对象实例（但，对象实例都分配在堆上，不是绝对的）
Java 堆是垃圾收集器管理的主要区域，很多时候也被称为“GC堆（Garbage Collected Heap）”
根据 Java 虚拟机规范规定：Java 堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可

- 堆内存划分
分代收集法的角度：
新生代、老年代（细致一点：Eden 空间、From Survivor空间、To Survivor空间等）

内存分配的角度：
线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）

- 异常
`OutOfMemoryError`：堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出

## 方法区（Method Area）
**简单理解：线程共享、存放对象实例以外的数据**

**方法区**：与 Java 堆一样，被所有线程共享的一块内存区域。
方法区用于存储：已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
类信息：存储类名、访问修饰符、常量池、字段描述、方法描述等
习惯在 HotSpot 虚拟机上开发、部署的开发者，更愿意将方法区称为“永久代（Permanent Generation）”

- 垃圾回收的目标
对常量池的回收、对类型的卸载

- 异常
`OutOfMemoryError`：方法区无法满足内存分配时，抛出

#### 运行时常量池（Runtime Constant Pool Table）
**简单理解：线程共享、存放字面量、符号引用、直接引用**

**运行时常量池**：方法区的一部分。
Class 文件除了有类的版本、字段、方法、接口等描述信息；还有一项信息，便是常量池，用于存放编译期生成的各种字面量和字符引用，这部分内容（常量池）将在类加载后进入方法区的运行时常量池中存放。
不过，一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

- 动态性
Java 语言并不要求常量一定只在编译期产生，运行期间也可能将新的常量放入池中。（比如：String 的 intern() 方法）

- 异常
`OutOfMemoryError`：常量池无法再申请到内存时，抛出

## 直接内存（Direct Memory）
**直接内存**：这块内存区域，不是虚拟机运行时的数据区域的一部分，也不是 Java 虚拟机规范中定义的内存区域。
Nio 操作时，为提高效率，避免在 Java 堆和 Native 堆中来回复制数据，运行直接操作堆外内，即直接内存。

- 异常
`OutOfMemoryError`：虚拟机设置的内存大于物理内存限制，虚拟机内存动态扩展时无法达到设置值时，抛出

## 总结一下
#### 概念及要点
- 程序计数器：字节码的行号指示器
Java 方法：记录字节码指令的地址
Native 方法：记录值为空

- 虚拟机栈：Java 方法调用的内存模型
存放**栈桢**；栈桢相当于是对方法的描述
栈桢：存储局部变量表、操作数栈、动态链表、方法出口等信息
局部变量表：存放编译期可知的各种基本数据类型、对象引用、returnAddress类型

- 本地方法栈：Native 方法调用的内存模型

- 堆：存储对象实例的内存空间
存放**实例对象**；物理地址可以不连续
堆内存划分：新生代、老年代（Eden 空间、From Survivor空间、To Survivor空间）；本地线程分配缓冲

- 方法区：存储对象实例以外数据的内存空间
存储已被虚拟机加载的**类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据
类信息：存储类名、访问修饰符、常量池、字段描述、方法描述等
运行时常量池：存放 Class 文件中的常量池（包含：字面量、符号引用）、直接引用；具有动态性


#### 同步策略
- 线程私有：程序计数器、虚拟机栈、本地方法栈
- 线程共享：堆、方法区

#### 异常
- 程序计数器：无异常
- 虚拟机栈：`StackOverflowError`、`OutOfMemoryError`
- 本地方法栈：`StackOverflowError`、`OutOfMemoryError`
- 堆：`OutOfMemoryError`
- 方法区：`OutOfMemoryError`
- 直接内存：`OutOfMemoryError`

---

参考：《深入理解Java虚拟机》